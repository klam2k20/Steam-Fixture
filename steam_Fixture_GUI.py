# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'steam_Fixture_GUI.ui'
#
# Created by: PyQt5 UI code generator 5.15.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import matplotlib.pyplot as plt
import xlsxwriter
import os
import sys
import time
import glob
import smtplib
import ADS1256
import RPi.GPIO as GPIO
import csv
import math
import numpy as np
import pandas as pd
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QMessageBox

#------------------------------------------------------------------ CONSTANTS & VARIABLES ------------------------------------------------------------------
STEAM_SENSOR1 = 6
STEAM_SENSOR2 = 5
STEAM_SENSOR3 = 4
TEMP_PROBE_STEAM = ''
TEMP_PROBE_SURR = ''
START_TIME = 0
THRESHOLD = 10
TIME_INTERVAL = .5

#-------------------------------------------------------------- SENSOR READING FUNCTIONS -------------------------------------------------------------------
def update_temp_id():
    global TEMP_PROBE_STEAM, TEMP_PROBE_SURR
    try:
        mypath = '/sys/bus/w1/devices/'
        onlylinks = [f for f in os.listdir(mypath) if os.path.islink(os.path.join(mypath, f))]
        onlylinks.remove('w1_bus_master1')
        TEMP_PROBE_SURR = str(onlylinks[0])
        TEMP_PROBE_STEAM = str(onlylinks[1])
    except IndexError:
        print('Temperature probes are not correctly connected')

def read_temp_raw(id):
    base_dir = '/sys/bus/w1/devices/'
    thermo_file = glob.glob(base_dir + id)[0] + '/w1_slave'
    f = open(thermo_file, 'r')
    lines = f.readlines()
    f.close()
    return lines
 
def read_temp(id):
    lines = read_temp_raw(id)
    while lines[0].strip()[-3:] != 'YES':
        lines = read_temp_raw(id)
    equals_pos = lines[1].find('t=')
    if equals_pos != -1:
        temp_string = lines[1][equals_pos+2:]
        temp_c = float(temp_string) / 1000.0
        return temp_c

#--------------------------------------------------------------------- DIRECTORY FUNCTION -----------------------------------------------------------------------
def new_Dir():
    DATE = time.ctime().split(' ')
    path1 = os.getcwd() + '/' + 'RAW DATA'
    path2 = path1 + "/" + DATE[1] + DATE[2] + DATE[4]
    
    if not os.path.exists(path1):
        os.mkdir(path1)
        os.mkdir(path2)
    elif not os.path.exists(path2):
        os.mkdir(path2)
    
    onlylinks = [f for f in os.listdir(path2) if os.path.isdir(os.path.join(path2, f))]
    counter = len(onlylinks)
    file_path = path2 + "/" + str(counter)
    os.mkdir(file_path)
    os.chdir(file_path)
    return counter
        
#--------------------------------------------------------------------- EXCEL FUNCTION -----------------------------------------------------------------------
def excel_FileName(counter, SENSOR_HEIGHT):
    return 'Steam_Fixture_' + str(counter) + '.xlsx'

def dataframe_to_Excel(counter, df, derivative_df, average_Sensor_Humidity, steam_Accum, FOOD_LOAD, MONITOR_TIME, TIME_INTERVAL, SENSOR_HEIGHT, INITIAL_MASS, FINAL_MASS, STEAM_APPLIANCE, FUNCTION):
    input_df = input_to_df(df,FOOD_LOAD, MONITOR_TIME, TIME_INTERVAL, SENSOR_HEIGHT, INITIAL_MASS, FINAL_MASS, average_Sensor_Humidity, steam_Accum, STEAM_APPLIANCE, FUNCTION)
    writer = pd.ExcelWriter(excel_FileName(counter, SENSOR_HEIGHT), engine='xlsxwriter')
    df.to_excel(writer, sheet_name= 'Raw_Steam_Fixture_Data')
    input_df.to_excel(writer, sheet_name= 'Procedure_Results_Data')
    derivative_df.to_excel(writer, sheet_name= 'Top Derivative - Time')
    workbook = writer.book
    worksheet = workbook.add_worksheet('Graphs')
    worksheet.insert_image(0,0,'Steam_Fixture_Graphs.png')
    writer.save()
#--------------------------------------------------------------------- HELPER FUNCTIONS --------------------------------------------------------------------
def update_Delta_Time(start):
    currentTime = time.time()
    deltaTime = currentTime - start
    return deltaTime/60.0

def to_Humidity(raw):
    return (raw/0x7fffff) * 100.00

def format_best_fit_eq(m,b):
    return 'y = ' + '{0:.2f}'.format(m) + 'x +' + '{0:.2f}'.format(b)

def input_to_df(df, FOOD_LOAD, MONITOR_TIME, TIME_INTERVAL, SENSOR_HEIGHT, INITIAL_MASS, FINAL_MASS, average_Sensor_Humidity, steam_Accum, STEAM_APPLIANCE, FUNCTION):
    input_dict = {'Steam Appliance':['Function', 'Food Load', 'Cook Time (min)', 'Time Interval (min)', 'Sensor Height (in)', 'Initial Mass (g)', 'Final Mass (g)', 'Water Loss (g)',
                               'Average Steam Sensor Humidity (%)', 'Steam Accumulation (Count * min)', 'Average Steam Temperature (C)'],
                    STEAM_APPLIANCE: [FUNCTION, FOOD_LOAD, MONITOR_TIME, TIME_INTERVAL, SENSOR_HEIGHT, INITIAL_MASS, FINAL_MASS, INITIAL_MASS - FINAL_MASS,
                                         average_Sensor_Humidity, steam_Accum, average_steam_temperature(df)] }
    input_df = pd.DataFrame(input_dict)
    return input_df

#----------------------------------------------------------------- DATAFRAME FUNCTION -------------------------------------------------------------------
def dataframe_Structure():
    columns = {'Time (min)':[], 'Steam Sensor 1 (Count)':[], 'Humidity 1 (%)':[],'Steam Sensor 2 (Count)':[], 'Humidity 2 (%)':[], 
            'Steam Sensor 3 (Count)':[], 'Humidity 3 (%)':[], 'Steam Temp. (C)':[], 'Surrounding Temp. (C)':[]}
    df = pd.DataFrame(columns)
    return df

def update_Dataframe(deltaTime, ADC_Value, df):
    global TEMP_PROBE_STEAM, TEMP_PROBE_SURR, STEAM_SENSOR1, STEAM_SENSOR2, STEAM_SENSOR3, START_TIME
    analog_Steam_Sensor_1 = ADC_Value[STEAM_SENSOR1]
    analog_Steam_Sensor_2 = ADC_Value[STEAM_SENSOR2]
    analog_Steam_Sensor_3 = ADC_Value[STEAM_SENSOR3]
    humidity_Steam_Sensor_1 = to_Humidity(analog_Steam_Sensor_1)
    humidity_Steam_Sensor_2 = to_Humidity(analog_Steam_Sensor_2)
    humidity_Steam_Sensor_3 = to_Humidity(analog_Steam_Sensor_3)
    if ((humidity_Steam_Sensor_1 >= THRESHOLD) | (humidity_Steam_Sensor_2 >= THRESHOLD) | (humidity_Steam_Sensor_3 >= THRESHOLD)) & (START_TIME == 0):
        START_TIME = deltaTime
    if START_TIME != 0:
        new_row = {'Time (min)':deltaTime, 
                'Steam Sensor 1 (Count)':analog_Steam_Sensor_1, 'Humidity 1 (%)':humidity_Steam_Sensor_1,
                'Steam Sensor 2 (Count)':analog_Steam_Sensor_2, 'Humidity 2 (%)':humidity_Steam_Sensor_2, 
                'Steam Sensor 3 (Count)':analog_Steam_Sensor_3, 'Humidity 3 (%)':humidity_Steam_Sensor_3, 
                'Steam Temp. (C)':read_temp(TEMP_PROBE_STEAM), 'Surrounding Temp. (C)':read_temp(TEMP_PROBE_SURR)}
        df = df.append(new_row, ignore_index = True)
        return df
    return df
                    
def average_Steam_Sensor_Humidity(df):
    total = df['Humidity 1 (%)'].sum() + df['Humidity 2 (%)'].sum() + df['Humidity 3 (%)'].sum()
    rows = len(df.index)
    return total/(3*rows)

def average_steam_temperature(df):
    return df['Steam Temp. (C)'].mean()

def average_surrounding_humidity(df):
    return df['Surrounding Humidity (%)'].mean()

def average_surrounding_temperature(df):
    return df['Surrounding Temp. (C)'].mean()
    
def steam_Accumulation(df):
    df['Delta T (min)'] = abs(df['Time (min)'].diff(periods=-1))
    df['Steam Accumulation (Count * min)'] = (df['Steam Sensor 1 (Count)'] * df['Delta T (min)']) + (df['Steam Sensor 2 (Count)'] * df['Delta T (min)']) + (df['Steam Sensor 3 (Count)'] * df['Delta T (min)'])
    return df['Steam Accumulation (Count * min)'].sum()

def dataframe_Empty_Check(df):
    if df.empty:
        print('Dataframe empty. Steam sensor threshold maybe too high or steam sensors maybe broken')
        sys.exit()

#----------------------------------------------------------------- GRAPH FUNCTION -------------------------------------------------------------------
def humidity_Graph(df):
    plt.plot('Time (min)', 'Humidity 1 (%)', data = df, color = 'red')
    plt.plot('Time (min)', 'Humidity 2 (%)', data = df, color = 'black')
    plt.plot('Time (min)', 'Humidity 3 (%)', data = df, color = 'blue')
    plt.xlabel('Time (min)')
    plt.ylabel('Humidity (%)')
    plt.title('Time vs. Steam Sensor\'s Humidity')
    plt.legend(loc='center left', bbox_to_anchor=(1, 0.5))

def steam_Accumulation_Graph(df, time_interval, MONITOR_TIME):
    start_Interval = df.iloc[0]['Time (min)']
    end_Interval = start_Interval + time_interval
    legend = []
    label = []
    derivative_time = dict()
    while start_Interval < MONITOR_TIME:
        df2 = df.loc[(df['Time (min)'] >= start_Interval) & (df['Time (min)'] <= end_Interval)]
        x = df2['Time (min)']
        y = df2['Steam Accumulation (Count * min)']
        m,b = np.polyfit(x,y,1)
        plt.plot(x,y,'ro')
        best_fit, = plt.plot(x, m*x+b)
        legend.append(best_fit,)
        label.append(format_best_fit_eq(m,b))
        derivative_time[m] = start_Interval
        start_Interval = end_Interval
        end_Interval = start_Interval + time_interval
    plt.plot('Time (min)', 'Steam Accumulation (Count * min)', 'o', data = df, color = 'red')
    plt.xlabel('Time (min)')
    plt.ylabel('Steam Accum. (Count * min)')
    plt.title('Time vs. Steam Accumulation')
    #plt.legend(legend, label,loc='center left', bbox_to_anchor=(1, 0.5))
    return derivative_time

def temperature_Graph(df):
    plt.plot('Time (min)', 'Steam Temp. (C)', data = df, color = 'red')
    plt.plot('Time (min)', 'Surrounding Temp. (C)', data = df, color = 'blue')
    plt.xlabel('Time (min)')
    plt.ylabel('Temperature (C)')
    plt.title('Time vs. Steam Temperature vs Surrounding Temperature')
    plt.legend(loc='center left', bbox_to_anchor=(1, 0.5))

def steam_Fixture_Graphs(df,time_interval, MONITOR_TIME):
    plt.figure(num=None, figsize=(10, 10), dpi=80, facecolor='w', edgecolor='k')
    plt.subplot(311)
    derivative_time = steam_Accumulation_Graph(df,time_interval,MONITOR_TIME)

    plt.subplot(312)
    humidity_Graph(df)

    plt.subplot(313)
    temperature_Graph(df)

    plt.tight_layout()
    return derivative_time
    
#----------------------------------------------------------------- GUI FUNCTION -------------------------------------------------------------------
class myLineEdit(QtWidgets.QLineEdit):
    def check_state(self, *args, **kwargs):
        validator = self.validator()
        state = validator.validate(self.text(), 0)[0]
        if state == QtGui.QValidator.Acceptable:
            color = '#c4df9b' # green
        elif state == QtGui.QValidator.Intermediate:
            color = '#fff79a' # yellow
        else:
            color = '#f6989d' # red
        self.setStyleSheet('QLineEdit { background-color: %s }' % color)

class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(800, 550)

        self.steam_Fixture_GUI = QtWidgets.QWidget(MainWindow)
        self.steam_Fixture_GUI.setObjectName("steam_Fixture_GUI")
        self.verticalLayoutWidget = QtWidgets.QWidget(self.steam_Fixture_GUI)
        self.verticalLayoutWidget.setGeometry(QtCore.QRect(10, 20, 201, 401))
        self.verticalLayoutWidget.setObjectName("verticalLayoutWidget")
        self.inputs = QtWidgets.QVBoxLayout(self.verticalLayoutWidget)
        self.inputs.setContentsMargins(0, 0, 0, 0)
        self.inputs.setObjectName("inputs")

        #VALIDATORS
        regexp = QtCore.QRegExp(r"[\w]+")
        self.alphanumeric_validator = QtGui.QRegExpValidator(regexp)
        regexp = QtCore.QRegExp(r"([1-9][0-9]*(\.[0-9]*[1-9])?|0\.[0-9]*[1-9])")
        self.double_validator = QtGui.QRegExpValidator(regexp)
        regexp = QtCore.QRegExp(r"[a-zA-Z]+")
        self.string_validator = QtGui.QRegExpValidator(regexp)

        #CREATE QLINEEDIT INPUTS
        self.create_input_line_edits()

        #CREATE QLINEEDIT OUTPUTS
        self.create_output_line_edits()

        #CREATE QLISTWIDGE SLOPE
        self.create_slope_list()

        #CREATE BUTTONS
        self.create_buttons()

        #CREATE GRAPH
        self.create_graph_pixmap()

        #VALIDATE QLINEEDIT INPUTS
        self.validate_input_line_edits()

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)
        
    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Steam Fixture GUI"))
        self.steam_appliance.setPlaceholderText(_translate("MainWindow", "Steam Appliance:"))
        self.function.setPlaceholderText(_translate("MainWindow", "Function:"))
        self.food_load.setPlaceholderText(_translate("MainWindow", "Food Load:"))
        self.monitor_time.setPlaceholderText(_translate("MainWindow", "Monitor Time (min):"))
        self.sensor_height.setPlaceholderText(_translate("MainWindow", "Sensor Height (in):"))
        self.initial_mass.setPlaceholderText(_translate("MainWindow", "Initial Mass (g):"))
        self.final_mass.setPlaceholderText(_translate("MainWindow", "Final Mass (g):"))
        self.water_loss.setPlaceholderText(_translate("MainWindow", "Steam Accumulation (Count * min): "))
        self.steam_sensor_humidity.setPlaceholderText(_translate("MainWindow", "Steam Sensors\' Average Humidity (%): "))
        self.steam_accumulation.setPlaceholderText(_translate("MainWindow", "Water Loss (g):"))
        self.start_button.setText(_translate("MainWindow", "Start"))
        self.quit_button.setText(_translate("MainWindow", "Quit"))
        self.graphs.setText(_translate("MainWindow", "Graphs"))
        self.format_initial_slope_list()
    
    def create_input_line_edits(self):
        self.steam_appliance = myLineEdit(self.verticalLayoutWidget)
        self.steam_appliance.setObjectName("steam_appliance")
        self.inputs.addWidget(self.steam_appliance)

        self.function = myLineEdit(self.verticalLayoutWidget)
        self.function.setObjectName("function")
        self.inputs.addWidget(self.function)
        
        self.food_load = myLineEdit(self.verticalLayoutWidget)
        self.food_load.setObjectName("food_load")
        self.inputs.addWidget(self.food_load)

        self.monitor_time = myLineEdit(self.verticalLayoutWidget)
        self.monitor_time.setObjectName("monitor_time")
        self.inputs.addWidget(self.monitor_time)

        self.sensor_height = myLineEdit(self.verticalLayoutWidget)
        self.sensor_height.setObjectName("sensor_height")
        self.inputs.addWidget(self.sensor_height)

        self.initial_mass = myLineEdit(self.verticalLayoutWidget)
        self.initial_mass.setObjectName("initial_mass")
        self.inputs.addWidget(self.initial_mass)

        self.final_mass = myLineEdit(self.verticalLayoutWidget)
        self.final_mass.setObjectName("final_mass")
        self.inputs.addWidget(self.final_mass)
        self.final_mass.setEnabled(False)

    def create_output_line_edits(self):
        self.verticalLayoutWidget_2 = QtWidgets.QWidget(self.steam_Fixture_GUI)
        self.verticalLayoutWidget_2.setGeometry(QtCore.QRect(220, 20, 241, 401))
        self.verticalLayoutWidget_2.setObjectName("verticalLayoutWidget_2")
        self.outputs = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_2)
        self.outputs.setContentsMargins(0, 0, 0, 0)
        self.outputs.setObjectName("outputs")

        self.water_loss = myLineEdit(self.verticalLayoutWidget_2)
        self.water_loss.setObjectName("water_loss")
        self.outputs.addWidget(self.water_loss)
        self.water_loss.setEnabled(False)

        self.steam_sensor_humidity = myLineEdit(self.verticalLayoutWidget_2)
        self.steam_sensor_humidity.setObjectName("steam_sensor_humidity")
        self.outputs.addWidget(self.steam_sensor_humidity)
        self.steam_sensor_humidity.setEnabled(False)

        self.steam_accumulation = myLineEdit(self.verticalLayoutWidget_2)
        self.steam_accumulation.setObjectName("steam_accumulation")
        self.outputs.addWidget(self.steam_accumulation)
        self.steam_accumulation.setEnabled(False)

    def create_slope_list(self):
        self.slope = QtWidgets.QListWidget(self.verticalLayoutWidget_2)
        self.slope.setObjectName("slope")
        item = QtWidgets.QListWidgetItem()
        font = QtGui.QFont()
        font.setBold(True)
        font.setWeight(75)
        item.setFont(font)
        counter = 0
        while counter < 11:
            self.slope.addItem(item)
            item = QtWidgets.QListWidgetItem()
            counter +=1
        self.outputs.addWidget(self.slope)
    
    def format_initial_slope_list(self):
        _translate = QtCore.QCoreApplication.translate
        __sortingEnabled = self.slope.isSortingEnabled()
        self.slope.setSortingEnabled(False)
        item = self.slope.item(0)
        item.setText(_translate("MainWindow", "Slope (Count) - Time (min):"))
        counter = 1
        while counter < 11:
            item = self.slope.item(counter)
            row = str(counter) + '. '
            item.setText(_translate("MainWindow", row))
            counter += 1
        self.slope.setSortingEnabled(__sortingEnabled)

    def create_buttons(self):
        self.start_button = QtWidgets.QPushButton(self.steam_Fixture_GUI)
        self.start_button.setGeometry(QtCore.QRect(160, 460, 231, 20))
        self.start_button.setObjectName("start_button")
        self.start_button.clicked.connect(self.start_function)
        self.start_button.setEnabled(False)

        self.quit_button = QtWidgets.QPushButton(self.steam_Fixture_GUI)
        self.quit_button.setGeometry(QtCore.QRect(410, 460, 231, 20))
        self.quit_button.setObjectName("quit_button")
        self.quit_button.clicked.connect(self.quit_function)
    
    def create_graph_pixmap(self):
        self.graphs = QtWidgets.QLabel(self.steam_Fixture_GUI)
        self.graphs.setGeometry(QtCore.QRect(470, 20, 321, 401))
        font = QtGui.QFont()
        font.setPointSize(22)
        font.setBold(True)
        font.setWeight(75)
        self.graphs.setFont(font)
        self.graphs.setAlignment(QtCore.Qt.AlignHCenter|QtCore.Qt.AlignTop)
        self.graphs.setObjectName("graphs")
        MainWindow.setCentralWidget(self.steam_Fixture_GUI)

    def validate_input_line_edits(self):
        input_list = [self.steam_appliance, self.function, self.food_load, self.monitor_time, self.sensor_height, self.initial_mass]

        #Connect validator to line edits
        self.steam_appliance.setValidator(self.alphanumeric_validator)
        self.function.setValidator(self.string_validator)
        self.food_load.setValidator(self.string_validator)
        self.monitor_time.setValidator(self.double_validator)
        self.sensor_height.setValidator(self.double_validator)
        self.initial_mass.setValidator(self.double_validator)

        #Connect line edits to function
        for i in input_list:
            i.textChanged.connect(i.check_state)
            i.textChanged.emit(i.text())
            i.textChanged.connect(self.enable_start)

    def format_final_slope_list(self,d):
        _translate = QtCore.QCoreApplication.translate
        sorted_derivative = sorted(d, reverse=True)
        dict_len = len(sorted_derivative)
        derivative_df_structure = {'Derivative (Count * min)':[], 'Time (min)':[]}
        derivative_df = pd.DataFrame(derivative_df_structure)
        counter = 1
        if  dict_len < 10:
            for derivative in sorted_derivative:
                if not math.isnan(derivative):
                    derivative_df_new_row = {'Derivative (Count * min)':derivative, 'Time (min)':d[derivative]}
                    derivative_df = derivative_df.append(derivative_df_new_row, ignore_index = True)
                    item = self.slope.item(counter)
                    item.setText(_translate("MainWindow", ' {0}. {1:.2f} @ {2:.2f}'.format(counter, derivative, d[derivative])))
                    counter += 1
        else:
            for derivative in sorted_derivative[:10]:
                if not math.isnan(derivative):
                    derivative_df_new_row = {'Derivative (Count * min)':derivative, 'Time (min)':d[derivative]}
                    derivative_df = derivative_df.append(derivative_df_new_row, ignore_index = True)
                    item = self.slope.item(counter)
                    item.setText(_translate("MainWindow", ' {0}. {1:.2f} @ {2:.2f}'.format(counter, derivative, d[derivative])))
                    counter += 1
        return derivative_df

    def enable_start(self):
        qLineEdit_list = [self.steam_appliance, self.function, self.food_load, self.monitor_time, self.sensor_height, self.initial_mass]
        inputs_valid = True
        for q in qLineEdit_list:
            if q.validator().validate(q.text(), 0)[0] == QtGui.QValidator.Intermediate:
                inputs_valid = False
        if inputs_valid:
            self.start_button.setEnabled(True)
        else:
            self.start_button.setEnabled(False)
    
    def enable_resume(self):
        if self.final_mass.validator().validate(self.final_mass.text(), 0)[0] == QtGui.QValidator.Intermediate:
            self.resume_button.setEnabled(False)
        else:
            self.resume_button.setEnabled(True)

    def start_function(self):
        global df, STEAM_APPLIANCE, FUNCTION, FOOD_LOAD, MONITOR_TIME, SENSOR_HEIGHT, INITIAL_MASS, COUNTER, TIME_INTERVAL 
        _translate = QtCore.QCoreApplication.translate
        self.start_button.setEnabled(False)
        self.steam_appliance.setEnabled(False)
        self.function.setEnabled(False)
        self.food_load.setEnabled(False)
        self.monitor_time.setEnabled(False)
        self.sensor_height.setEnabled(False)
        self.initial_mass.setEnabled(False)

        COUNTER = new_Dir()
        update_temp_id()

        STEAM_APPLIANCE = self.steam_appliance.text().strip()
        FUNCTION = self.function.text().strip()
        FOOD_LOAD = self.food_load.text().strip()
        MONITOR_TIME = float(self.monitor_time.text().strip())
        SENSOR_HEIGHT = float(self.sensor_height.text().strip())
        INITIAL_MASS = float(self.initial_mass.text().strip())
    
        try:
            df = dataframe_Structure()
            startTime = time.time()
            deltaTime = 0
            ADC = ADS1256.ADS1256()
            ADC.ADS1256_init()
            while (deltaTime < MONITOR_TIME):
                ADC_Value = ADC.ADS1256_GetAll()
                deltaTime = update_Delta_Time(startTime)
                df = update_Dataframe(deltaTime, ADC_Value, df)
                time.sleep(2)
            dataframe_Empty_Check(df)

            self.final_mass_popup()

            self.resume_button = QtWidgets.QPushButton(self.verticalLayoutWidget)
            self.resume_button.setObjectName("resume_button")
            self.inputs.addWidget(self.resume_button)
            self.resume_button.setText(_translate("MainWindow", "Resume"))
            self.resume_button.clicked.connect(self.resume_function)
            self.resume_button.setEnabled(False)
            
            self.final_mass.setEnabled(True)
            self.final_mass.setValidator(self.double_validator)
            self.final_mass.textChanged.connect(self.final_mass.check_state)
            self.final_mass.textChanged.emit(self.final_mass.text())
            self.final_mass.textChanged.connect(self.enable_resume)

            df = df
            STEAM_APPLIANCE = STEAM_APPLIANCE
            FUNCTION = FUNCTION
            FOOD_LOAD = FOOD_LOAD
            MONITOR_TIME = MONITOR_TIME
            SENSOR_HEIGHT = SENSOR_HEIGHT
            INITIAL_MASS = INITIAL_MASS
     
            
        except :
            GPIO.cleanup()
            print ("\r\nProgram end     ")
            exit()

    def quit_function(self):
        sys.exit()
    
    def resume_function(self):
        global df, FOOD_LOAD, MONITOR_TIME, SENSOR_HEIGHT, INITIAL_MASS, STEAM_APPLIANCE, FUNCTION, COUNTER, TIME_INTERVAL
        FINAL_MASS = float(self.final_mass.text().strip())
        water_loss = INITIAL_MASS - FINAL_MASS
        average_Sensor_Humidity = average_Steam_Sensor_Humidity(df)
        steam_Accum = steam_Accumulation(df)
        derivative_time = steam_Fixture_Graphs(df,TIME_INTERVAL, MONITOR_TIME)
        self.water_loss.setText('{0:,.2f}'.format(water_loss))
        self.steam_accumulation.setText('{0:,.2f}'.format(steam_Accum))
        self.steam_sensor_humidity.setText('{0:,.2f}'.format(average_Sensor_Humidity))
        derivative_df = self.format_final_slope_list(derivative_time)
        plt.savefig('Steam_Fixture_Graphs.png')
        dataframe_to_Excel(COUNTER, df, derivative_df, average_Sensor_Humidity, steam_Accum, FOOD_LOAD, MONITOR_TIME, TIME_INTERVAL, SENSOR_HEIGHT, INITIAL_MASS, FINAL_MASS, STEAM_APPLIANCE, FUNCTION)
        self.graphs.setPixmap(QtGui.QPixmap('Steam_Fixture_Graphs.png'))
        self.graphs.setScaledContents(True)
        self.resume_button.setEnabled(False)
    
    def final_mass_popup(self):
        msg = QMessageBox()
        msg.setText("Enter Final Mass (g)")
        msg.setIcon(QMessageBox.Information)
        msg.exec()
        

    
if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
